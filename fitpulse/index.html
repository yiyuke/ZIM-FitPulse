<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>FitPulse</title>

<!--
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ZIM Zapps
Progressive Web App (PWA) tool output from
https://zimjs.com/zapps/tool.html 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-->

<!-- ZIM PWA STEP 1 - MANIFEST -->
<link rel="manifest" href="manifest.json">

<!-- ZIM PWA STEP 2 - META -->
<meta name="apple-mobile-web-app-title" content="FitPulse">
<meta name="theme-color" content="#333333">
<meta name="msapplication-TileColor" content="#333333">

<meta name="viewport" content="width=device-width, user-scalable=no">
<link rel="apple-touch-icon" href="icons/icon_152.png">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="msapplication-TileImage" content="icons/icon_144.png">

<!-- should have faveicons - see link below -->
<!-- see https://www.favicon-generator.org/ -->

<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="msapplication-starturl" content="./">

<!-- ZIM PWA STEP 3 - SERVICE WORKER -->
<script>
	window.addEventListener("DOMContentLoaded", function () {
		if (location.protocol === "https:" && "serviceWorker" in navigator) navigator.serviceWorker.register("./serviceworker.js");
	});
</script>


<script src="libraries/createjs.js"></script>
<script src="libraries/zim_min.js"></script>

<!-- zimjs.com - JavaScript Canvas Framework -->
<script type="module">
const assets = "icon.png";
const path = "assets/"

new Frame(FULL, null, null, light, dark, ready, assets, path);
function ready() {

	// ZIM PWA STEP 4 - ADD TO HOME SCREEN (A2HS)
	// NOTE: new PWA() works with ZIM Cat 04 or beyond
	// Message shows if only if running from mobile Browser
	// See https://zimjs.com/docs.html?item=PWA for more options
	// Will want to move this to bottom of app code

	new PWA();

    const container = new Container().center();

    // const logo = new Pic("icon.png")
    //     .scaleTo(S, 30, 50)
    //     .center(container)
    //     .drag();
    // Create balance indicator ring
    const ring = new Circle({
        radius: 100,
        borderColor: purple,
        borderWidth: 10,
        color: "transparent"
    }).center(container);

    // Add inner progress ring
    const progressRing = new Shape().addTo(container);
    
    // Add tilt display
    const tiltDisplay = new Label({
        text: "Deviation: 0°",
        size: 20,
        color: red,
    }).center(container)

    function setupTiltDetection() {
        console.log("Setting up improved movement detection");
        
        // 添加计数相关变量
        let repCount = 0;
        let lastPositionY = 0;
        let highestPoint = 0;
        let lowestPoint = 0;
        let isMovingDown = false;
        let isMovingUp = false;
        let inProgress = false;
        
        // 定义移动阈值（单位：厘米）
        const MOVEMENT_THRESHOLD = 20; // 需要上下移动至少20厘米才计数
        
        // 添加调试显示
        const debugDisplay = new Label({
            text: "位置: 0cm",
            size: 20,
            color: white,
            backgroundColor: "#333333",
            padding: 10,
            corner: 5
        }).pos(0, -140, LEFT, TOP, container);
        
        // 添加计数显示
        const repCountDisplay = new Label({
            text: "次数: 0",
            size: 30,
            color: white,
            backgroundColor: "#333333",
            padding: 10,
            corner: 5
        }).pos(0, 80, LEFT, TOP, container);
        
        // 添加状态显示
        const statusDisplay = new Label({
            text: "状态: 准备",
            size: 20,
            color: white,
            backgroundColor: "#333333",
            padding: 10,
            corner: 5
        }).pos(0, 120, LEFT, TOP, container);
        
        // 使用位置积分来跟踪垂直移动
        let positionY = 0;
        let velocityY = 0;
        let lastTime = Date.now();
        
        // 监听设备方向变化
        window.addEventListener("deviceorientation", (event) => {
            // 获取旋转值
            const beta = event.beta || 0;  // x轴旋转 (-180 到 180)
            const gamma = event.gamma || 0; // y轴旋转 (-90 到 90)
            
            // 计算绝对值
            const absBeta = Math.abs(beta);
            const absGamma = Math.abs(gamma);
            
            // 计算总体倾斜度
            const totalDeviation = Math.sqrt(absBeta * absBeta + absGamma * absGamma);
            
            // 显示倾斜度
            tiltDisplay.text = `倾斜: ${totalDeviation.toFixed(1)}°\n前后: ${absBeta.toFixed(1)}°, 左右: ${absGamma.toFixed(1)}°`;
            
            // 更新环的颜色和大小
            if (totalDeviation > 20) {
                ring.borderColor = "#ff0000"; // 红色表示严重倾斜
                ring.scaleX = ring.scaleY = 0.7;
            } else if (totalDeviation > 10) {
                ring.borderColor = "#ff9800"; // 橙色表示中度倾斜
                ring.scaleX = ring.scaleY = 0.85;
            } else if (totalDeviation > 5) {
                ring.borderColor = "#FFEB3B"; // 黄色表示轻微倾斜
                ring.scaleX = ring.scaleY = 0.95;
            } else {
                ring.borderColor = "#4CAF50"; // 绿色表示水平
                ring.scaleX = ring.scaleY = 1;
            }

            // 绘制进度环
            const progress = Math.min(totalDeviation / 20, 1);
            progressRing.graphics.clear()
                .setStrokeStyle(5)
                .beginStroke(ring.borderColor)
                .arc(0, 0, 80, 0, Math.PI * 2 * progress);
            
            S.update();
        });
        
        // 监听设备加速度变化来估算位置
        window.addEventListener("devicemotion", (event) => {
            const now = Date.now();
            const dt = (now - lastTime) / 1000; // 转换为秒
            lastTime = now;
            
            if (dt <= 0 || dt > 0.2) return; // 忽略不合理的时间间隔
            
            // 获取加速度数据（包括重力）
            const acceleration = event.accelerationIncludingGravity;
            if (!acceleration) return;
            
            // 获取垂直方向加速度（通常是y轴，但可能因设备方向而异）
            // 尝试所有轴以找到最适合垂直方向的
            const x = acceleration.x || 0;
            const y = acceleration.y || 0;
            const z = acceleration.z || 0;
            
            // 使用最大的加速度分量作为垂直方向
            // 这是一个简化的方法，实际应用中可能需要更复杂的方向检测
            const verticalAccel = Math.max(Math.abs(x), Math.abs(y), Math.abs(z)) * 
                                 (Math.abs(y) === Math.max(Math.abs(x), Math.abs(y), Math.abs(z)) ? 
                                  Math.sign(y) : Math.sign(z));
            
            // 应用低通滤波器减少噪声
            const filteredAccel = verticalAccel - 9.8; // 减去重力加速度
            
            // 积分加速度得到速度
            velocityY += filteredAccel * dt;
            
            // 应用阻尼以防止漂移
            velocityY *= 0.95;
            
            // 积分速度得到位置
            positionY += velocityY * dt * 100; // 转换为厘米
            
            // 检测动作
            if (!inProgress && Math.abs(positionY - lastPositionY) > 5) {
                // 开始新的动作
                inProgress = true;
                highestPoint = positionY;
                lowestPoint = positionY;
                statusDisplay.text = "状态: 开始动作";
            }
            
            if (inProgress) {
                // 更新最高点和最低点
                if (positionY > highestPoint) highestPoint = positionY;
                if (positionY < lowestPoint) lowestPoint = positionY;
                
                // 检测下蹲
                if (positionY < lastPositionY - 2) {
                    isMovingDown = true;
                    isMovingUp = false;
                    statusDisplay.text = "状态: 下蹲中";
                }
                
                // 检测站立
                if (positionY > lastPositionY + 2) {
                    isMovingUp = true;
                    isMovingDown = false;
                    statusDisplay.text = "状态: 站立中";
                }
                
                // 检测完整动作
                const totalMovement = Math.abs(highestPoint - lowestPoint);
                
                // 当动作停止且移动距离足够大时计数
                if (Math.abs(velocityY) < 5 && totalMovement > MOVEMENT_THRESHOLD && isMovingUp) {
                    repCount++;
                    repCountDisplay.text = `次数: ${repCount}`;
                    console.log(`完成一次硬拉: ${repCount}, 移动距离: ${totalMovement.toFixed(1)}cm`);
                    
                    // 添加视觉反馈
                    // new Circle({
                    //     radius: 120,
                    //     color: "#4CAF50",
                    //     alpha: 0.5
                    // }).center(container).animate({
                    //     props: {alpha:0, scale:1.5},
                    //     time: 500,
                    //     onComplete: function(tween) {
                    //         tween.target.removeFrom();
                    //     }
                    // });
                    
                    // 重置状态
                    inProgress = false;
                    isMovingDown = false;
                    isMovingUp = false;
                    statusDisplay.text = "状态: 完成";
                    
                    // 延迟后重置位置跟踪，避免连续计数
                    setTimeout(() => {
                        positionY = 0;
                        velocityY = 0;
                        lastPositionY = 0;
                        statusDisplay.text = "状态: 准备";
                    }, 1000);
                }
            }
            
            // 更新显示
            debugDisplay.text = `位置: ${positionY.toFixed(1)}cm\n速度: ${velocityY.toFixed(1)}cm/s\n移动: ${Math.abs(highestPoint - lowestPoint).toFixed(1)}cm`;
            
            lastPositionY = positionY;
            S.update();
        });
    }

    // 处理权限
    if (typeof DeviceOrientationEvent !== 'undefined' && 
        typeof DeviceOrientationEvent.requestPermission === 'function') {
        
        // 添加权限按钮
        const permissionButton = new Button({
            width: 200,
            height: 50,
            label: "开始训练",
            backgroundColor: blue,
            rollBackgroundColor: "#1976D2",
            corner: 10
        }).center(container);

        permissionButton.on("click", async () => {
            try {
                // 请求设备方向权限
                const orientationPermission = await DeviceOrientationEvent.requestPermission();
                
                // 请求设备运动权限（如果可用）
                let motionPermission = "granted";
                if (typeof DeviceMotionEvent !== 'undefined' && 
                    typeof DeviceMotionEvent.requestPermission === 'function') {
                    motionPermission = await DeviceMotionEvent.requestPermission();
                }
                
                if (orientationPermission === "granted" && motionPermission === "granted") {
                    setupTiltDetection();
                    permissionButton.removeFrom();
                }
            } catch (error) {
                console.error("Error requesting permission:", error);
            }
        });
    } else {
        setupTiltDetection();
    }

    S.update();
}
</script>

</head>
<body></body>
</html>