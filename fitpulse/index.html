<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>FitPulse</title>

<!--
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ZIM Zapps
Progressive Web App (PWA) tool output from
https://zimjs.com/zapps/tool.html 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-->

<!-- ZIM PWA STEP 1 - MANIFEST -->
<link rel="manifest" href="manifest.json">

<!-- ZIM PWA STEP 2 - META -->
<meta name="apple-mobile-web-app-title" content="FitPulse">
<meta name="theme-color" content="#333333">
<meta name="msapplication-TileColor" content="#333333">

<meta name="viewport" content="width=device-width, user-scalable=no">
<link rel="apple-touch-icon" href="icons/icon_152.png">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="msapplication-TileImage" content="icons/icon_144.png">

<!-- should have faveicons - see link below -->
<!-- see https://www.favicon-generator.org/ -->

<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="msapplication-starturl" content="./">

<!-- ZIM PWA STEP 3 - SERVICE WORKER -->
<script>
	window.addEventListener("DOMContentLoaded", function () {
		if (location.protocol === "https:" && "serviceWorker" in navigator) navigator.serviceWorker.register("./serviceworker.js");
	});
</script>


<script src="libraries/createjs.js"></script>
<script src="libraries/zim_min.js"></script>

<!-- zimjs.com - JavaScript Canvas Framework -->
<script type="module">
import zim from "https://zimjs.org/cdn/017/zim_socket";

const assets = "icon.png";
const path = "assets/";

new Frame(FULL, null, null, "#2B2730", dark, ready, assets, path);
function ready() {
    new PWA();

    // Create app state
    let appState = {
        screen: "home",
        mode: "solo",
        duration: 30,
        playerName: "Player1",
        repCount: 0,
        warnings: 0,
        avgTilt: 0,
        tiltReadings: [],
        gameConclusionType: "completed",
        socket: null,
        isReady: false
    };

    // Main container for all screens
    const homeScreen = new Container().center();
    const gameScreen = new Container().center().vis(false);
    const resultsScreen = new Container().center().vis(false);
    const aboutScreen = new Container().center().vis(false);
    const roomScreen = new Container().center().vis(false);

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // HOME SCREEN
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // ---------------- HEADER -----------------
    const header = new Container(500,150).pos(0,0, CENTER, TOP)//.outline();
    const logo = new Label({
        text: "FitPulse",
        size: 48,
        color: "#BD00E3",//purple
        bold: true
    }).loc(200, 50, header);

    const icon = new Pic("assets/icon.png").centerReg().sca(.2).loc(148,70,header);

    // ---------------- MODE SELECTION -----------------
    new Label({
        text:"👋🏻 Welcome!",
        size: 36,
        color: white
    }).loc(-110, -260, homeScreen);

    new Label({
        text: "Mode Selection",
        size: 24,
        color: white
    }).loc(-100, -90, homeScreen);
    
    let modeRadio = new RadioButtons({
        size: 20,
        buttons: ["Solo", "Multiplayer"],
        vertical:false,
        selectedIndex: 0,
        spacing: 10,
        color: "#41B900",//green
        backgroundColor: light
    }).loc(-100, -50, homeScreen)
    .on("change", function() {
        appState.mode = this.selectedIndex == 0 ? "solo" : "multiplayer";
    });
    
    // Duration selection
    new Label({
        text: "Duration",
        size: 24,
        color: white
    }).loc(-100, -180, homeScreen);
    
    let durationRadio = new RadioButtons({
        size: 20,
        buttons: ["30s", "60s"],
        selectedIndex: 0,
        vertical:false,
        spacing: 10,
        color: "#41B900",//green,
        backgroundColor: light
    }).loc(-100, -140, homeScreen)
    .on("change", function() {
        appState.duration = this.selectedIndex == 0 ? 30 : 60;
    });
    
    // Player name
    new Label({
        text: "Player Name",
        size: 24,
        color: white
    }).loc(-100, 0, homeScreen);
    
    let nameInput = new TextInput({
        placeholder:"Player1",
        width:220,
        height:48,
        backgroundColor:light,
        borderColor:white,
        borderWidth:2,
        corner:5
    }).loc(-100, 40, homeScreen)
    .on("change", function() {
        appState.playerName = this.text || "Player1";
    });
    
    // Start button
    const startButton = new Button({
        label:"START",
        width:240,
        height:60,
        backgroundColor:"#BD00E3",//purple
        rollBackgroundColor:"#8A00A3",//darker purple
        corner:10
    }).loc(-114, 200, homeScreen)
    .on("click", function() {
        // Request device orientation permission first before proceeding with any game mode
        function requestOrientationPermission() {
            return new Promise((resolve) => {
                if (typeof DeviceOrientationEvent !== 'undefined' && 
                    typeof DeviceOrientationEvent.requestPermission === 'function') {
                    // iOS 13+ requires permission
                    DeviceOrientationEvent.requestPermission()
                        .then(permissionState => {
                            if (permissionState === 'granted') {
                                console.log('Device orientation permission granted.');
                                resolve(true);
                            } else {
                                console.log('Device orientation permission denied.');
                                resolve(false);
                            }
                        })
                        .catch(error => {
                            console.error('Error requesting device orientation permission:', error);
                            resolve(false);
                        });
                } else {
                    // Non iOS 13+ devices don't need permission
                    console.log('Device orientation permission not required for this device.');
                    resolve(true);
                }
            });
        }

        // Request permission and proceed with the game mode after permission is handled
        requestOrientationPermission().then(permissionGranted => {
            if (!permissionGranted) {
                new Pane({
                    label: "Device orientation permission is required to play this game.",
                    backgroundColor: dark,
                    color: white,
                    modal: true
                }).show();
                return;
            }
            
            // Continue with original game mode selection flow
            if (appState.mode === "multiplayer") {
                try {
                    // Initialize socket
                    appState.socket = new zim.Socket(
                        zimSocketURL,      // server
                        "fitpulse",        // appName
                        "room1",           // roomName
                        4,                 // maxPeople
                        true              // fill
                    );

                    // Handle socket ready event
                    appState.socket.on("ready", () => {
                        console.log("Socket ready, connected as:", appState.socket.id);
                        // Send initial player data using setProperties
                        appState.socket.setProperties({
                            name: appState.playerName,
                            ready: false,
                            reps: 0,
                            status: "waiting"
                        });
                        showRoomScreen();
                    });

                    // Handle socket error
                    appState.socket.on("error", (error) => {
                        console.error("Socket error:", error);
                        new Pane({
                            label: "Could not connect to multiplayer server",
                            backgroundColor: dark,
                            color: white,
                            modal: true
                        }).show();
                        appState.mode = "solo";
                        modeRadio.selectedIndex = 0;
                    });

                } catch (e) {
                    console.error("Socket initialization error:", e);
                    appState.mode = "solo";
                    modeRadio.selectedIndex = 0;
                }
            } else {
                showScreen("game");
                startGame();
            }
        });
    });

    // ---------------- Nav Footer -----------------
    const navFooter = new Container(500,100).pos(0,0, CENTER, BOTTOM)//.outline();
    const aboutButton = new Label({
        text:"ABOUT",
        size:24,
        color: light,
        corner:0,
    }).loc(70,10, navFooter)
    .on("click",function() {
        homeScreen.vis(false);
        gameScreen.vis(false);
        resultsScreen.vis(false);
        aboutScreen.vis(true);
        S.update();
    });

    const homeButton = new Label({
        text:"HOME",
        size:24,
        color: light,
        corner:0,
    }).loc(220,10, navFooter)
    .on("click",function() {
        resetGameState();
        showScreen("home");
        aboutScreen.vis(false);
        S.update();
    });

    const youButton = new Label({
        text:"YOU",
        size:24,
        color: light,
        corner:0,
    }).loc(370,10, navFooter)
    .on("click",function() {
        showScreen("you");
        aboutScreen.vis(false);
        S.update();
    });

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // ROOM SCREEN
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
    // Room Screen Setup
    function showRoomScreen() {
        roomScreen.removeAllChildren();
        showScreen("room");

        // Track connected players
        const connectedPlayers = new Map();
        let gameStarting = false;  // Flag to prevent multiple game starts

        // Room header
        new Label({
            text: "Waiting Room",
            size: 36,
            color: white,
            bold: true
        }).loc(-110, -260, roomScreen);

        const playersContainer = new Container().loc(0, -150, roomScreen);
        
        const updatePlayerList = () => {
            playersContainer.removeAllChildren();
            let yPos = 0;
            
            // Add current player
            new Label({
                text: `👤 ${appState.playerName} ${appState.isReady ? '(Ready ✓)' : '(Not Ready)'}`,
                size: 20,
                color: white
            }).loc(-100, yPos, playersContainer);
            yPos += 40;

            // Add other players
            connectedPlayers.forEach((player, id) => {
                if (id !== appState.socket.id && player.name) {
                    console.log("Displaying player:", player);
                    new Label({
                        text: `👤 ${player.name} ${player.ready ? '(Ready ✓)' : '(Not Ready)'}`,
                        size: 20,
                        color: white
                    }).loc(-100, yPos, playersContainer);
                    yPos += 40;
                }
            });
            S.update();
        };

        const checkAndStartGame = () => {
            if (gameStarting) return; // Prevent multiple starts

            let allReady = true;
            let validPlayers = 0;
            
            // Count current player
            if (appState.isReady) validPlayers++;
            else allReady = false;

            // Check other players
            connectedPlayers.forEach((player) => {
                if (player.name) {
                    validPlayers++;
                    if (!player.ready) allReady = false;
                }
            });

            console.log("Game check - All ready:", allReady, "Valid players:", validPlayers);

            // Start game only if we have at least 2 players and all are ready
            if (allReady && validPlayers >= 2) {
                showScreen("game");
                startGame();
                gameStarting = true;
            }
        };

        // Socket events
        if (appState.socket) {
            // Handle data updates
            appState.socket.on("data", (data) => {
                console.log("Received data update:", data);

                // Handle regular player updates
                if (data && data.id) {
                    const existingPlayer = connectedPlayers.get(data.id);
                    if (!existingPlayer || !existingPlayer.timestamp || 
                        (data.timestamp && data.timestamp > existingPlayer.timestamp)) {
                        
                        connectedPlayers.set(data.id, {
                            name: data.name,
                            ready: data.ready,
                            status: data.status,
                            timestamp: data.timestamp
                        });
                        updatePlayerList();
                        
                        // Check if we should start the game
                        if (!gameStarting) {
                            checkAndStartGame();
                        }
                    }
                }
            });

            // Initial state setup
            appState.socket.setProperties({
                name: appState.playerName,
                ready: false,
                status: "waiting",
                timestamp: Date.now()
            });

            // Handle new player joining
            appState.socket.on("otherjoin", (data) => {
                console.log("Other player joined:", data);
                if (data && data.id) {
                    // Send our current state to the new player
                    appState.socket.setProperties({
                        name: appState.playerName,
                        ready: appState.isReady,
                        status: appState.isReady ? "ready" : "waiting",
                        timestamp: Date.now()
                    });
                }
            });
            
            // Handle player leaving
            appState.socket.on("otherleave", (data) => {
                console.log("Other player left:", data);
                if (data && data.id) {
                    connectedPlayers.delete(data.id);
                    updatePlayerList();
                    
                    // If game was about to start but someone left, cancel it
                    if (gameStarting) {
                        gameStarting = false;
                        showRoomScreen(); // Reset the room screen
                    }
                }
            });
        }

        // Ready button
        const readyButton = new Button({
            label: "READY",
            width: 200,
            height: 60,
            backgroundColor: "#41B900",
            rollBackgroundColor: "#388E3C",
            corner: 10
        }).loc(-100, 100, roomScreen)
        .on("click", function() {
            if (appState.socket) {
                appState.isReady = true;
                appState.socket.setProperties({
                    name: appState.playerName,
                    ready: true,
                    status: "ready",
                    timestamp: Date.now()
                });
                this.alpha = 0.5;
                this.enabled = false;
                updatePlayerList();
                checkAndStartGame();
            }
        });

        // Back button
        new Button({
            label: "BACK",
            width: 200,
            height: 60,
            backgroundColor: "#FF6000",
            rollBackgroundColor: "#CC4D00",
            corner: 10
        }).loc(-100, 200, roomScreen)
        .on("click", function() {
            if (appState.socket) {
                appState.socket.dispose();
                appState.socket = null;
            }
            appState.isReady = false;
            gameStarting = false;  // Reset game starting flag
            resetGameState();
            showScreen("home");
            S.update();
        });

        updatePlayerList();
    }
    
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // GAME SCREEN SETUP
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Tilt detection setup
    function setupTiltDetection() {
        // Clear game screen first
        gameScreen.removeAllChildren();
        
        // Add timer display
        const timerLabel = new Label({
            text: `${appState.duration}s`,
            size: 30,
            color: white,
            bold: true
        }).loc(-100, -260, gameScreen);

        // Add rep counter display
        const repLabel = new Label({
            text: "Reps: 0",
            size: 30,
            color: white,
            bold: true
        }).loc(20, -260, gameScreen);
        
        // Create tilt display
        const tiltDisplay = new Label({
            text: "Tilt: 0.0°",
            size: 24,
            color: white,
            align: CENTER
        }).centerReg().loc(4, 26, gameScreen)//.outline();
        
        // Create balance ring
        const ring = new Circle({
            radius: 100,
            color: null,
            borderColor: "#41B900", // Green for level
            borderWidth: 10
        }).center(gameScreen).mov(2, 25)//.outline();
        
        // Create progress ring
        const progressRing = new Shape().centerReg(gameScreen).mov(null, 150);
        
        // Add manual rep counter button (from your original code)
        const countButton = new Button({
            label: "Count: 0",
            size: 20,
            width: 174,
            height: 60,
            backgroundColor: "#41B900",//green
            rollBackgroundColor: "#388E3C",
            corner: 10
        }).loc(-160, -200, gameScreen);
        
        // Button click event
        countButton.on("click", function() {
            appState.repCount++;
            countButton.text = `Count: ${appState.repCount}`;
            repLabel.text = `Reps: ${appState.repCount}`;

            // Button animation effect
            countButton.animate({
                props: {scale:1.1},
                time: 100,
                rewind: true
            });
            
            S.update();
        });
        
        // Add reset button
        const resetButton = new Button({
            label: "Reset",
            width: 130,
            height: 60,
            backgroundColor: "#BD00E3",//purple
            rollBackgroundColor: "#8A00A3",//darker purple
            corner: 10
        }).loc(32, -200, gameScreen);
        
        // Reset button click event
        resetButton.on("click", function(e) {
            e.stopPropagation();
            
            appState.repCount = 0;
            countButton.text = `Count: ${appState.repCount}`;
            repLabel.text = `Reps: ${appState.repCount}`;
            
            S.update();
        });
        
        // Variables for tilt detection
        let isInDownPosition = false;
        let warningActive = false;
        let dangerThreshold = 20; // Threshold for warning
        let failureThreshold = 25; // Threshold for failure
        
        // Timer functionality
        let timeRemaining = appState.duration;
        let timerInterval = setInterval(() => {
            timeRemaining--;
            timerLabel.text = `${timeRemaining}s`;
            
            if (timeRemaining <= 0) {
                clearInterval(timerInterval);
                window.removeEventListener("deviceorientation", handleOrientation);
                showScreen("results");
            }
            
            S.update();
        }, 1000);
        
        // Add device orientation listener directly since permission was already granted
        console.log('Adding deviceorientation event listener...');
        window.addEventListener('deviceorientation', handleOrientation);
        
        // Device orientation handler
        function handleOrientation(event) {
            console.log('Device orientation event:', event);
            // Get rotation values
            const beta = event.beta || 0;  // x-axis rotation (-180 to 180)
            const gamma = event.gamma || 0; // y-axis rotation (-90 to 90)
            
            // Calculate absolute values
            const absBeta = Math.abs(beta);
            const absGamma = Math.abs(gamma);
            
            // Calculate total deviation
            const totalDeviation = Math.sqrt(absBeta * absBeta + absGamma * absGamma);
            
            // Store tilt reading for average calculation
            appState.tiltReadings.push(totalDeviation);
            
            // Display tilt
            tiltDisplay.text = `Tilt: ${totalDeviation.toFixed(1)}°`;
            
            // Sync data in multiplayer mode
            if (appState.mode === "multiplayer" && appState.socket) {
                appState.socket.setProperties({
                    repCount: appState.repCount,
                    warnings: appState.warnings,
                    avgTilt: appState.avgTilt
                });
            }
            
            // Update ring color and size
            if (totalDeviation > failureThreshold) {
                ring.borderColor = "#ff0000"; // Red for severe tilt
                ring.scaleX = ring.scaleY = 0.7;
                
                if (!warningActive) {
                    warningActive = true;
                    appState.warnings++;
                    
                    // Vibrate if supported
                    if (navigator.vibrate) {
                        navigator.vibrate(200);
                    }
                    
                    // Check for failure
                    if (appState.warnings > 3) {
                        // Game over due to excessive warnings
                        clearInterval(timerInterval);
                        window.removeEventListener("deviceorientation", handleOrientation);
                        appState.gameConclusionType = "failed"; // Mark as failed
                        showScreen("results");
                    }
                    
                    // Reset warning after 3 seconds
                    setTimeout(() => {
                        warningActive = false;
                    }, 3000);
                }
            } else if (totalDeviation > dangerThreshold) {
                ring.borderColor = "#ff9800"; // Orange for moderate tilt
                ring.scaleX = ring.scaleY = 0.85;
            } else if (totalDeviation > 5) {
                ring.borderColor = "#FFEB3B"; // Yellow for slight tilt
                ring.scaleX = ring.scaleY = 0.95;
            } else {
                ring.borderColor = "#4CAF50"; // Green for level
                ring.scaleX = ring.scaleY = 1;
            }

            // Draw progress ring
            const progress = Math.min(totalDeviation / 20, 1);
            progressRing.graphics.clear()
                .setStrokeStyle(5)
                .beginStroke(ring.borderColor)
                .arc(0, 0, 80, 0, Math.PI * 2 * progress);
            
            // Automatic rep counting based on tilt pattern
            // Detect downward movement (increasing beta)
            if (!isInDownPosition && absBeta > 40) {
                isInDownPosition = true;
            }
            // Detect upward movement (decreasing beta)
            else if (isInDownPosition && absBeta < 15) {
                isInDownPosition = false;
                // Count a rep
                appState.repCount++;
                repLabel.text = `Reps: ${appState.repCount}`;
                countButton.text = `Count: ${appState.repCount}`;
                
                // Provide feedback
                if (navigator.vibrate) {
                    navigator.vibrate(100);
                }
            }
            
            S.update();
        }
        
        // Add control buttons at the bottom
        const buttonContainer = new Container().loc(0, 200, gameScreen);
        
        // Add a back button to game screen
        new Button({
            label: "QUIT",
            color: "#2B2730",//dark gray
            width: 150,
            height: 60,
            backgroundColor: "#DDDDDE",//light gray
            rollBackgroundColor: "#d32f2f",
            corner: 6
        }).loc(-160, 0, buttonContainer)
        .on("click", function() {
            clearInterval(timerInterval);
            window.removeEventListener("deviceorientation", handleOrientation);
            appState.gameConclusionType = "quit"; // Set the conclusion type
            resetGameState();
            if (appState.mode === "multiplayer" && appState.socket) {
                appState.socket.dispose();
                appState.socket = null;
                appState.isReady = false;
                showScreen("home");
            } else {
                showScreen("home");
            }
            S.update();
        });
        
        // Add a finish button to end the game early
        new Button({
            label: "FINISH",
            width: 150,
            height: 60,
            backgroundColor: "#FF6000",//orange
            rollBackgroundColor: "#CC4D00",//darker orange
            corner: 6
        }).loc(10, 0, buttonContainer)
        .on("click", function() {
            clearInterval(timerInterval);
            window.removeEventListener("deviceorientation", handleOrientation);
            appState.gameConclusionType = "finished"; // Set the conclusion type
            if (appState.mode === "multiplayer" && appState.socket) {
                appState.socket.setProperties({
                    name: appState.playerName,
                    reps: appState.repCount,
                    finished: true,
                    timestamp: Date.now()
                });
                showScreen("results");
            } else {
                showScreen("results");
            }
            S.update();
        });
    }


    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
    // RESULTS SCREEN
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    function showResultsScreen() {
        // Calculate average tilt
        if (appState.tiltReadings.length > 0) {
            appState.avgTilt = appState.tiltReadings.reduce((a, b) => a + b, 0) / appState.tiltReadings.length;
        }
        
        resultsScreen.removeAllChildren();
        
        if (appState.mode === "multiplayer" && appState.socket) {
            // Track finished players
            const finishedPlayers = new Map();
            let expectedPlayers = 0;

            // Add our score
            finishedPlayers.set(appState.socket.id, {
                name: appState.playerName,
                reps: appState.repCount
            });

            // Get current players count from socket data
            const currentData = appState.socket.data || {};
            expectedPlayers = Object.keys(currentData).length + 1; // +1 for current player

            // Send our final score
            appState.socket.setProperties({
                name: appState.playerName,
                reps: appState.repCount,
                finished: true,
                timestamp: Date.now()
            });

            // Create waiting message
            const waitingLabel = new Label({
                text: "🏁 You finished early!\nLet's see how you ranked against others.",
                size: 24,
                color: white,
                align: CENTER,
                lineHeight: 28
            }).center(resultsScreen).mov(0,-50);

            // Listen for other players' results
            appState.socket.on("data", (data) => {
                if (data && data.id && data.finished) {
                    console.log("Player finished:", data.name);
                    
                    finishedPlayers.set(data.id, {
                        name: data.name,
                        reps: data.reps
                    });
                    
                    // Check if all players have finished
                    const allFinished = finishedPlayers.size >= expectedPlayers;
                    
                    // If we're the last to finish, broadcast a completed event
                    if (allFinished) {
                        console.log("All players have finished!");
                        appState.socket.setProperties({
                            name: appState.playerName,
                            reps: appState.repCount,
                            finished: true,
                            allCompleted: true,
                            timestamp: Date.now()
                        });
                        showFinalResults();
                    } 
                    // If another player has indicated all are complete
                    else if (data.allCompleted) {
                        console.log("Received completion notification");
                        showFinalResults();
                    }
                    
                    S.update();
                }
            });

            // Function to show final results
            const showFinalResults = () => {
                resultsScreen.removeAllChildren();
                S.update();
                // Show player name
                new Label({
                    text: appState.playerName,
                    size: 36,
                    color: white,
                    bold: true
                }).pos(0, -220, CENTER, CENTER, resultsScreen);

                // Convert finished players to array and sort by reps
                const players = Array.from(finishedPlayers.values());
                players.sort((a, b) => b.reps - a.reps);

                // Find player's rank
                const playerRank = players.findIndex(p => p.name === appState.playerName) + 1;
                const totalPlayers = players.length;

                // Show rank or failure message
                let resultMessage = "";
                if (appState.gameConclusionType === "failed") {
                    resultMessage = "❌ You were weeded out due to excessive warnings.";
                } else if (playerRank === 1) {
                    resultMessage = "🥇 You're the Champion!\nOutstanding performance!";
                } else if (playerRank === 2) {
                    resultMessage = "🥈 Great job!\nYou came in 2nd place!";
                } else if (playerRank === 3) {
                    resultMessage = "🥉 Nice try!\nYou placed 3rd.\nKeep improving!";
                } else {
                    resultMessage = `🏅 You placed #${playerRank}.\nStay steady and come back stronger!`;
                }

                new Label({
                    text: resultMessage,
                    size: 24,
                    color: white,
                    align: CENTER,
                    lineHeight: 30
                }).loc(0, -150, resultsScreen);

                // Show all players' scores
                let yPos = -50;
                players.forEach((player, index) => {
                    const isCurrentPlayer = player.name === appState.playerName;
                    new Label({
                        text: `${index + 1}. ${player.name}: ${player.reps} reps`,
                        size: 24,
                        color: isCurrentPlayer ? "#BD00E3" : white,
                        bold: isCurrentPlayer,
                        lineHeight: 30
                    }).loc(-66, yPos, resultsScreen);
                    yPos += 40;
                    S.update();
                });
            };

            // Set a timeout to force show final results after 10 seconds
            // This ensures the last player also sees results
            setTimeout(() => {
                if (resultsScreen.numChildren <= 1) {  // If still showing waiting screen
                    console.log("Forcing results display after timeout");
                    showFinalResults();
                }
            }, 10000);

        } else {
            // Solo mode results
            new Label({
                text: appState.playerName,
                size: 36,
                color: white,
                bold: true
            }).pos(0, -220, CENTER, CENTER, resultsScreen);

            let resultMessage = "";
            if (appState.gameConclusionType === "quit") {
                 resultMessage = "👋 Session ended early.\nCome back when you're ready to try again!";
             } else if (appState.gameConclusionType === "finished") {
                 resultMessage = "⏱️ Early finish!\nGood effort on your workout today.";
             } else if (appState.warnings > 3) {
                 resultMessage = "⚠️ Oops!\nYou lost balance too many times.";
             } else {
                resultMessage = "🎉 Nice work!\nYou kept your balance and finished strong!";
            }

            new Label({
                text: resultMessage,
                size: 20,
                color: white,
                align: CENTER,
                lineHeight: 30
            }).loc(0, -150, resultsScreen);

            new Label({
                text: `✅ Reps: ${appState.repCount}`,
                size: 24,
                color: white
            }).loc(-80, 70,resultsScreen);
 
            new Label({
                text: `🎯 Avg Tilt: ${appState.avgTilt.toFixed(1)}°`,
                size: 24,
                color: white
            }).loc(-80, 20,resultsScreen);
 
            new Label({
                text: `⚠️ Warnings: ${appState.warnings}`,
                size: 24,
                color: white
            }).loc(-80, -30,resultsScreen);

            // Retry button
            new Button({
                label: "RETRY",
                width: 240,
                height: 60,
                backgroundColor: "#41B900",
                rollBackgroundColor: "#388E3C",
                corner: 6
            }).loc(-114, 200, resultsScreen)
            .on("click", function() {
                resetGameState();
                showScreen("game");
                startGame();
            });
        }
    }
    
    // Helper functions
    function showScreen(screenName) {
        appState.screen = screenName;
        homeScreen.vis(false);
        gameScreen.vis(false);
        resultsScreen.vis(false);
        aboutScreen.vis(false);
        roomScreen.vis(false);
        
        if (screenName === "home") homeScreen.vis(true);
        else if (screenName === "game") gameScreen.vis(true);
        else if (screenName === "results") {
            showResultsScreen();
            resultsScreen.vis(true);
        } else if (screenName === "room") {
            roomScreen.vis(true);
        }
        
        S.update();
    }
    
    function resetGameState() {
        appState.repCount = 0;
        appState.warnings = 0;
        appState.tiltReadings = [];
        appState.avgTilt = 0;
        appState.gameConclusionType = "completed"; // Reset the conclusion type
        if (appState.socket) {
            appState.socket.dispose();
            appState.socket = null;
        }
        appState.isReady = false;
        S.update();
    }
    
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // GAME COUNTDOWN SCREEN
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    function startGame() {
        // Clear game screen first
        gameScreen.removeAllChildren();
        
        // Create countdown container
        const countdownContainer = new Container().center(gameScreen);
        const countdownLabel = new Label({
            text: "3",
            size: 100,
            color: "#BD00E3", // purple
            bold: true
        }).center(countdownContainer);
        
        // Countdown animation
        let count = 3;
        const countdownInterval = setInterval(() => {
            count--;
            if (count > 0) {
                countdownLabel.text = count;
                // Add a scale animation effect
                countdownLabel.animate({
                    props: {scale:1.5},
                    time: 200,
                    rewind: true
                });
            } else {
                clearInterval(countdownInterval);
                countdownContainer.removeFrom(gameScreen);
                // Start the actual game setup
                setupTiltDetection();
            }
            S.update();
        }, 1000);
    }
    
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // ABOUT SCREEN
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Back button
    const backButton = new Button({
        label: "<",
        width: 50,
        height: 50,
        backgroundColor: "#2B2730", // dark gray    
        rollBackgroundColor: "#1976D2",
        corner: 25
    }).pos(-178, -320, LEFT, TOP, aboutScreen)
    .on("click", function() {
        aboutScreen.vis(false);
        if (appState.screen === "home") {
            homeScreen.vis(true);
        } else if (appState.screen === "game") {
            gameScreen.vis(true);
        } else if (appState.screen === "results") {
            resultsScreen.vis(true);
        }
        S.update();
    });
    
    // Description
    new LabelWords({
        label: "FitPulse is a fun and interactive balance game that challenges your body and reflexes using real-time motion sensors. Play solo or challenge your friends!",
        size: 16,
        width: 360,
        color: white,
        align: LEFT,
    }).loc(-170, -250, aboutScreen);
    
    // How to Play section
    new Label({
        text: "How to Play",
        size: 24,
        color: white,
        bold: true
    }).loc(-170, -100, aboutScreen);
    
    // Instructions
    const instructions = new Container().loc(0, -50, aboutScreen);
    
    const instructionItems = [
        "1️⃣ Pick a Mode - Solo or Multiplayer",
        "2️⃣ Choose Time - 30s or 60s",
        "3️⃣ Deadlift on One Leg - Hold your phone steady",
        "4️⃣ Avoid Warnings - Stay in the green zone",
        "5️⃣ Do Reps - More reps = higher score!"
    ];
    
    let yPos = 0;
    instructionItems.forEach((item, index) => {
        new Label({
            text: item,
            size: 16,
            color: white,
            align: LEFT
        }).loc(-170, yPos, instructions);
        yPos += 40;
    });
    
    // GitHub button
    const githubLabel = new Label({
        text:"🌟 ON GITHUB",
        size:30,
        color:white,
    });
    const githubButton = new Button({
        label: githubLabel,
        width:240,
        height:60,
        backgroundColor:"#BD00E3", // purple
        rollBackgroundColor:"#1976D2",
        corner:10
    }).loc(-120, 200, aboutScreen)
    .on("click", function() {
        // Open GitHub repository in a new tab
        window.open("https://github.com/yiyuke/ZIM-FitPulse", "_blank");
    });

    // Start with home screen
    showScreen("home");
}
</script>

</head>
<body></body>
</html>